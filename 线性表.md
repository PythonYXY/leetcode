
# 560. 和为K的子数组

```
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

示例 1 :

输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
说明 :

数组的长度为 [1, 20,000]。
数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。
```
## 思路

是求和为0的子数组这道题基础上的扩展。如果数组前i个数的和sum[i - 1]比前j个数的和sum[j - 1]小k（i < j），则索引为[i, j - 1]的子数组的和即为k。拥有相同和的前缀可能不止一个，所以需要用哈希表来存储前缀和以及对应的前缀个数。另外为了包含i == 0的情况，需要提前在map中插入（0，1）对。

## 代码

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>(){{ map.put(0, 1); }};
        
        int sum = 0, res = 0;
        
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            
            if (map.containsKey(sum - k)) {
                res += map.get(sum - k);
            }
            
            map.put(sum, map.containsKey(sum) ? map.get(sum) + 1: 1);
        }
        
        
        return res;
    }
}
```

# 523 连续子数组和

```
给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。

示例 1:

输入: [23,2,4,6,7], k = 6
输出: True
解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。
示例 2:

输入: [23,2,6,4,7], k = 6
输出: True
解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。
说明:

数组的长度不会超过10,000。
你可以认为所有数字总和在 32 位有符号整数范围内。
```

## 思路
思路依然与连续子数组和为0差不多，只不过这里要求和是k的倍数，也即subarraySum % k == 0。可以考虑将计算前缀和改成计算前缀和余k的结果。如果长度为i的前缀和余k等于长度为j的前缀和余k（i < j），则索引为[i, j - 1]的子数组和余k即为0。另外这道题要求子数组长度至少为2，所以这里j至少要比i大1。另外与之前一样，需要考虑到i == 0的情况。

## 代码

```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        map.put(0, -1);
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (k != 0) sum %= k;
            
            if (map.containsKey(sum)) {
                if (i > map.get(sum) + 1) {
                    return true;
                }
            } else {
                map.put(sum, i);
            }
        }
        return false;
    }
}
```

# 209. 长度最小的子数组

```
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。

示例: 

输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。
进阶:

如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。
```

## 思路1
使用双指针法。在右指针right向右遍历的过程中，左指针left在区间和大于s的情况下不断地向右指针靠近，每更新一次区间长度就比较一下是否是最短区间。


## 代码1

```java
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        int len = Integer.MAX_VALUE, left = 0, right = 0, sum = 0;
        
        while (right < nums.length) {
            sum += nums[right];
            while (sum >= s && left <= right) {
                len = Math.min(len, right - left + 1);
                sum -= nums[left++];
            }
            right++;
        }
        
        if (len == Integer.MAX_VALUE) return 0;
        return len;
    }
}
```

## 思路2

使用二分法。这里需要注意一下排除中位数的逻辑。

## 代码2

```java
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        if (nums.length == 0) return 0;
        
        int[] sum = new int[nums.length];
        sum[0] = nums[0];
        
        for (int i = 1; i < nums.length; i++) { sum[i] = sum[i - 1] + nums[i]; }
        
        int len = Integer.MAX_VALUE;
        
        for (int i = 0; i < nums.length; i++) {
            
            int left = i, right = nums.length - 1;
            
            while (left < right) {
                int mid = (left + right) >>> 1;
                
                if (sum[mid] - sum[i] + nums[i] < s) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
                
                if (sum[left] - sum[i] + nums[i] >= s) {
                    len = Math.min(len, left - i + 1);
                }
            }
        }
        
        if (len == Integer.MAX_VALUE) return 0;
        return len;
    }
}
```

# 15. 三数之和

```
给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]

```

## 思路
主要思路就是将3Sum转化成2Sum：首先将数组按照升序排序，然后固定第三个数去搜索前两个数。这里需要注意的是对于重复结果的处理。

## 代码

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        
        List<List<Integer>> res = new ArrayList<>();
        
        for (int k = 2; k < nums.length; k++) {
            while (k + 1 < nums.length && nums[k] == nums[k + 1]) k++;
            int target = 0 - nums[k];
            
            int i = 0, j = k - 1;
            while (i < j) {
                int sum = nums[i] + nums[j];
                
                if (sum < target || (i > 0  && nums[i - 1] == nums[i])) i++;
                else if (sum > target || (j < k - 1 && nums[j] == nums[j + 1])) j--;
                else res.add(new ArrayList<>(Arrays.asList(nums[i++], nums[j--], nums[k])));
            }d
        }
        
        return res;
    }
}
```

# 215. 数组中的第K个最大元素

```
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
说明:

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
```

## 思路
主要还是借助快速排序的思想。这里重点说下快排中划分部分的算法。
划分算法有三步：
1、在区间范围内随机选择一个pivot，并与区间末尾的元素进行交换（这里的随机选择的方式可以尽量避免算法退化到O(n^2)。至于为什么选择末尾元素是因为这里的遍历方式是从前往后遍历的，同样的，若选择从后往前遍历就需要选择区间首部元素来进行交换了）。
2、设置一个partition索引，初始指向区间首部。在遍历区间的过程中如果发现当前索引位元素小于pivot，就将其与partition索引上的元素进行交换，同时partition增1。（将pivot放在末尾可以避免partition出界）
3、最后需要将pivot放在partition索引上。
这样在区间内partition之前的元素一定不大于pivot，而partition之后的元素一定不小于pivot。
## 代码
```java
import java.util.Random;
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return partition(nums, 0, nums.length - 1, nums.length - k);
    }
    
    public int partition(int[] nums, int start, int end, int target_index) {
        if (start == end) return nums[start];
        
        int pivot_index = start + new Random().nextInt(end - start + 1);
        swap(nums, pivot_index, end);
        
        int partition_index = start;
        for (int i = start; i <= end; i++) {
            if (nums[i] < nums[end]) { // 因为区间最后一个元素为pivot，所以当i等于end的时候该表达式一定不会成立，partition_index就一定不会出界
                swap(nums, i, partition_index++); 
            }
        }
        swap(nums, end, partition_index);
        
        if (partition_index == target_index) return nums[partition_index];
        if (partition_index < target_index) return partition(nums, partition_index + 1, end, target_index);
        return partition(nums, start, partition_index - 1, target_index);
    }
    
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

# 41. 缺失的第一个正数
```
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

示例 1:

输入: [1,2,0]
输出: 3
示例 2:

输入: [3,4,-1,1]
输出: 2
示例 3:

输入: [7,8,9,11,12]
输出: 1
说明:

你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/first-missing-positive
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 思路

借助桶排序的思想，将正整数放在对应的索引（该正数减去1）中，如果正数超过了数组索引范围，则忽略。最后从头遍历数组，若当前索引位的元素与索引位不对应，则当前索引位加1就是确实的第一个正数。

该题的难点在于如何在O(n)的时间复杂度内将各个正数归位。

对于数组上的每一个元素做如下操作：若当前元素是正数但与索引位不对应，如果其在数组的索引范围内，那么就将该元素与其对应位置的元素进行交换。如果交换过来的元素还满足上述条件，那么就继续进行上述操作。另外需要注意的是对于重复元素只需要交换一次。

## 代码

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            while (nums[i] > 0 && nums[i] - 1 < nums.length && nums[nums[i] - 1] != nums[i] && nums[i] - 1 != i) {
                swap(nums, i, nums[i] - 1);
            }
        }
        
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] - 1 != i) return i + 1;
        }
        
        return nums.length + 1;
    }
    
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

# 4. 寻找两个有序数组的中位数
```
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5


```

## 思路
https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu-b/

## 代码

```java
class Solution {
    public double findMedianSortedArrays(int[] A, int[] B) {
        int m = A.length;
        int n = B.length;
        if (m > n) { // to ensure m<=n
            int[] temp = A; A = B; B = temp;
            int tmp = m; m = n; n = tmp;
        }
        int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2;
        while (iMin <= iMax) {
            int i = (iMin + iMax) / 2;
            int j = halfLen - i;
            if (i < iMax && B[j-1] > A[i]){
                iMin = i + 1; // i is too small
            }
            else if (i > iMin && A[i-1] > B[j]) {
                iMax = i - 1; // i is too big
            }
            else { // i is perfect
                int maxLeft = 0;
                if (i == 0) { maxLeft = B[j-1]; }
                else if (j == 0) { maxLeft = A[i-1]; }
                else { maxLeft = Math.max(A[i-1], B[j-1]); }
                if ( (m + n) % 2 == 1 ) { return maxLeft; }

                int minRight = 0;
                if (i == m) { minRight = B[j]; }
                else if (j == n) { minRight = A[i]; }
                else { minRight = Math.min(B[j], A[i]); }

                return (maxLeft + minRight) / 2.0;
            }
        }
        return 0.0;
    }
}
```

