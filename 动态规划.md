# 337. 打家劫舍 III

```
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

示例 1:

输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
示例 2:

输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.

```

## 思路

一道典型的树状DP的题。

每个节点保存的状态是以当前节点为根节点的子树所能获得的最大值，具体分为包含当前节点和不包含当前节点这两种情况。

用自底向上的方法遍历整棵树。对于每一个节点，包含该节点的状态值为该节点值加上两个子节点不包含自身的状态值，而不包含该节点的状态值为两个子节点包含自身的状态值之和。

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int rob(TreeNode root) {
        int[] res = dp(root);
        return Math.max(res[0], res[1]);
    }
    
    public int[] dp(TreeNode root) {
        if (root == null) {
            return new int[]{0, 0};
        }
        
        int[] left = dp(root.left);
        int[] right = dp(root.right);
        
        return new int[]{Math.max(left[0], left[1]) + Math.max(right[0], right[1]), 
                         root.val + left[0] + right[0]};
    }
    
}
```

# 121. 买卖股票的最佳时机
```
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。


```

## 思路1
遍历prices数组，设置一个min变量存储到当前为止最小的价格。计算当前价格和min变量的差，并与最大利润进行比较。最大利润初始为0。

## 代码1
```java
    public int maxProfit(int[] prices) {
        if (prices.length == 0) return 0;
        int min = prices[0], res = 0;

        for (int i = 1; i < prices.length; i++) {
            if (prices[i] < min) min = prices[i];
            else res = Math.max(res, prices[i] - min);
        }

        return res;
    }
```

## 思路2
遍历prices数组，定义两个变量sold和hold。sold代表当前处于卖出状态时获得的最大利润，hold代表当前处于买入状态时获得的最大利润。卖出状态可以从卖出状态或者买入状态变迁得来，如果是从卖出状态变迁，则利润保持不变；如果是从买入状态变迁，利润增加当前的价格。买入状态可以从买入状态或者初始状态变迁得来，如果是从买入状态变迁，则利润保持不变，如果是从初始状态变迁，则利润为0-当前价格。初始时sold为0，hold为负无穷，代表初始时不可能处于卖出状态。最后返回卖出状态的最大利润。

## 代码2
```
public int maxProfit(int[] prices) {
    int hold = Integer.MIN_VALUE, sold = 0;

    for (int i = 0; i < prices.length; i++) {
        sold = Math.max(sold, hold + prices[i]);
        hold = Math.max(hold, 0 - prices[i]);
    }

    return sold;
}
```
    
    
# 122. 买卖股票的最佳时机 II

```
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。


```

## 思路1
https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode/
## 代码1
```java
    public int maxProfit(int[] prices) {
        int max = 0;

        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i - 1]) max += prices[i] - prices[i - 1];
        }

        return max;
    }
```
## 思路2
在121题的基础上稍微修改即可：买入状态可以从买入状态或者卖出状态变迁得来，从买入状态变迁，利润保持不变；从卖出状态变迁，利润为卖出状态的利润sold减去当前的价格。
## 代码2
```java
    public int maxProfit(int[] prices) {
        int sold = 0, hold = Integer.MIN_VALUE;

        for (int i = 0; i < prices.length; i++) {
            sold = Math.max(sold, hold + prices[i]);
            hold = Math.max(hold, sold - prices[i]);
        }

        return sold;
    }
```

# 123. 买卖股票的最佳时机 III
```给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3:

输入: [7,6,4,3,1] 
输出: 0 
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。

```

## 思路
在121题的基础上进行扩展。定义sold1和hold1，分别代表第一次卖出后和第一次买入后获得的利润，而sold2和hold2分别代表第二次卖出后和第二次买入后获得的利润。sold1与hold1的变迁公式与121题一致。第二次卖出状态可以由第二次卖出状态或者第二次买入状态变迁得来。第二次买入状态可以由第二次买入状态或者第一次卖出状态变迁得来。

## 代码

```java

class Solution {
    public int maxProfit(int[] prices) {
        int sold1 = 0, hold1 = Integer.MIN_VALUE;
        int sold2 = 0, hold2 = Integer.MIN_VALUE;

        for (int i = 0; i < prices.length; i++) {
            int preSold1 = sold1;
            sold1 = Math.max(sold1, hold1 + prices[i]);
            hold1 = Math.max(hold1, 0 - prices[i]);

            sold2 = Math.max(sold2, hold2 + prices[i]);
            hold2 = Math.max(hold2, preSold1 - prices[i]);
        }

        return sold2;
    }

}
```

# 188. 买卖股票的最佳时机 IV

```
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

输入: [2,4,1], k = 2
输出: 2
解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
示例 2:

输入: [3,2,6,5,0,3], k = 2
输出: 7
解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。

```

## 思路
该题是对121， 122， 123题的泛化。定义二维数组dp，dp[k][0]表示在最多可以完成k笔交易的情况下，当前处于卖出状态时所能获得的最大利润；dp[k][1]表示在最多可以完成k笔交易的情况下，当前处于买入状态时所能获得的最大利润。初始时对于任意k，dp[k][0]都等于0，而dp[k][1]都等于负无穷，代表初始时不可能处于卖出状态。状态变迁关系参考代码。

另外本题中会出现k值特别大的情况，因此需要做一定优化。当k值大于prices数组的一半长度时，相当于不再对交易次数进行限制，因此可以用122题的方法来解决。

## 代码
```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        if (k >= prices.length / 2) return maxProfit(prices);
        int[][] dp = new int[k + 1][2];
        for (int j = 0; j <= k; j++) {
            dp[j][1] = Integer.MIN_VALUE;
        }

        for (int i = 0; i < prices.length; i++) {
            for (int j = 1; j <= k; j++) {
                dp[j][0] = Math.max(dp[j][0], dp[j][1] + prices[i]);
                dp[j][1] = Math.max(dp[j][1], dp[j - 1][0] - prices[i]);
            }
        }

        return dp[k][0];
    }

    public int maxProfit(int[] prices) {
        int max = 0;

        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i - 1]) max += prices[i] - prices[i - 1];
        }

        return max;
    }
}
```

# 714. 买卖股票的最佳时机含手续费
```
给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

示例 1:

输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
注意:

0 < prices.length <= 50000.
0 < prices[i] < 50000.
0 <= fee < 50000.

```

## 思路
在122题的基础上稍作修改即可。在每一次买入的时候除了减去当前价格，还要额外减去手续费。（也可以在卖出的时候减去手续费，但是在代码中会有整数溢出的情况出现)
## 代码

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int sold = 0, hold = Integer.MIN_VALUE;

        for (int i = 0; i < prices.length; i++) {
            sold = Math.max(sold, hold + prices[i]);
            hold = Math.max(hold, sold - prices[i] - fee);
        }

        return sold;
    }
}
```

# 309. 最佳买卖股票时机含冷冻期
```
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
示例:

输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

```

## 思路
定义三个变量sold, rest, hold，分别代表当前处于卖出状态时获得的利润，当前处于休息状态时的利润，当前处于买入状态时获得的利润。卖出状态只能从买入状态变迁得来。买入状态可以从买入状态或者休息状态变迁得来。休息状态可以从休息状态或者卖出状态变迁得来。初始时sold和rest都为0，hold为负无穷。最后返回sold和rest中的最大值。

## 代码

```java
class Solution {
    public int maxProfit(int[] prices) {
        int sold = 0, rest = 0, hold = Integer.MIN_VALUE;


        for (int i = 0; i < prices.length; i++) {
            int preSold = sold;
            sold = hold + prices[i];
            hold = Math.max(hold, rest - prices[i]);
            rest = Math.max(rest, preSold);
        }

        return Math.max(sold, rest);
    }
}
```

# 120. 三角形最小路径和
```
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

说明：

如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。

```

## 思路
状态f(i, j)代表从(i, j)位置移动到三角底部的最小路径和，状态变迁公式为：f(i, j) = triangle(i, j) + Math.min(f(i + 1, j), f(i + 1, j + 1))。在本题中采用自底向上遍历的顺序，直接使用triangle数组存储结果，无需额外空间。

## 代码
```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        for (int i = triangle.size() - 2; i >= 0; i--) {
            for (int j = 0; j < triangle.get(i).size(); j++) {
                int old = triangle.get(i).get(j);
                triangle.get(i).set(j, old + Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1)));
            }
        }

        return triangle.get(0).get(0);
    }
}
```

# 152. 乘积最大子序列
```
给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

示例 1:

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
示例 2:

输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

## 思路
基本思路与最大连续子串和一样。不过要注意的是由于负数之间的乘积为正数，所以需要同时计算最小子串乘积。

## 代码
```java
class Solution {
    public int maxProduct(int[] nums) {
        int minVal = nums[0], maxVal = nums[0], res = nums[0];

        for (int i = 1; i < nums.length; i++) {
            int temp = maxVal;
            maxVal = Math.max(nums[i], Math.max(maxVal * nums[i], minVal * nums[i]));
            minVal = Math.min(nums[i], Math.min(minVal * nums[i], temp * nums[i]));
            res = Math.max(res, maxVal);
        }

        return res;
    }
}
```

# 132. 分割回文串 II
```
给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回符合要求的最少分割次数。

示例:

输入: "aab"
输出: 1
解释: 进行一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。

```
## 思路
设dp(i)表示范围为(0, i)的子串的最少分割次数。i=0时由于只有一个字符，所以其最小分割次数为0。

状态变迁公式为dp(i) = min(dp(j) + 1), -1 <= j < i, s[j + 1, i]为回文串。令dp(-1)为-1，因为当s[0, i]为回文串时，所需的最小分割次数为0，也即dp(i)=0。

## 代码
```java
class Solution {
    public int minCut(String s) {

        int[] dp = new int[s.length()];
        Arrays.fill(dp, s.length());
        dp[0] = 0;
        boolean[][] p = new boolean[s.length()][s.length()];

        for (int i = 0; i < s.length(); i++) {
            for (int j = -1; j < i; j++) {
                if (s.charAt(i) == s.charAt(j + 1) && (i - j - 1 <= 2 || p[j + 2][i - 1])) {
                    p[j + 1][i] = true;
                    dp[i] = Math.min(dp[i], j == -1 ? 0 : dp[j] + 1);
                }
            }
        }

        return dp[s.length() - 1];
    }
}
```

# 131. 分割回文串

```
给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回 s 所有可能的分割方案。

示例:

输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]

```

## 思路

## 代码

```java

class Solution {
    public List<List<String>> partition(String s) {
        boolean[][] p = new boolean[s.length()][s.length()];

        for (int i = 0; i < s.length(); i++) {
            for (int j = 0; j <= i; j++) {
                if (s.charAt(j) == s.charAt(i) && (i - j <= 2 || p[j + 1][i - 1])) p[j][i] = true;
            }
        }

        return helper(s, p, 0);
    }

    public List<List<String>> helper(String s, boolean[][] p, int start) {
        List<List<String>> res = new LinkedList();
        if (start == s.length()) {
            res.add(new LinkedList());
            return res;
        }

        for (int i = start; i < s.length(); i++) {
            if (p[start][i]) {
                List<List<String>> ret = helper(s, p, i + 1);
                for (List<String> list: ret) {
                    list.add(0, s.substring(start, i + 1));
                    res.add(list);
                }
            }
        }

        return res;
    }
}
```

# 85. 最大矩形
```
给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

示例:

输入:
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
输出: 6

```

## 思路
https://leetcode-cn.com/problems/maximal-rectangle/solution/zui-da-ju-xing-by-leetcode/

## 代码
```java

class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length == 0) return 0;
        int m = matrix.length;
        int n = matrix[0].length;

        int[] left = new int[n]; // initialize left as the leftmost boundary possible
        int[] right = new int[n];
        int[] height = new int[n];

        Arrays.fill(right, n); // initialize right as the rightmost boundary possible

        int maxarea = 0;
        for(int i = 0; i < m; i++) {
            int cur_left = 0, cur_right = n;
            // update height
            for(int j = 0; j < n; j++) {
                if(matrix[i][j] == '1') height[j]++;
                else height[j] = 0;
            }
            // update left
            for(int j=0; j<n; j++) {
                if(matrix[i][j]=='1') left[j]=Math.max(left[j],cur_left);
                else {left[j]=0; cur_left=j+1;}
            }
            // update right
            for(int j = n - 1; j >= 0; j--) {
                if(matrix[i][j] == '1') right[j] = Math.min(right[j], cur_right);
                else {right[j] = n; cur_right = j;}    
            }
            // update area
            for(int j = 0; j < n; j++) {
                maxarea = Math.max(maxarea, (right[j] - left[j]) * height[j]);
            }
        }
        return maxarea;
    }
}

```

# 97. 交错字符串
```
给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。

示例 1:

输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出: true
示例 2:

输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
输出: false

```

## 代码
```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        if (s3.length() != s1.length() + s2.length()) return false;
        
        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];
        dp[0][0] = true;

        for (int i = 1; i <= s1.length(); i++) {
            dp[i][0] = dp[i - 1][0] && (s1.charAt(i - 1) == s3.charAt(i - 1));
            if (!dp[i][0]) break;
        }

        for (int i = 1; i <= s2.length(); i++) {
            dp[0][i] = dp[0][i - 1] && (s2.charAt(i - 1) == s3.charAt(i - 1));
            if (!dp[0][i]) break;
        }

        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i - 1 + j)) ||
                           (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1 + i)); 
            }
        }

        return dp[s1.length()][s2.length()];
    }
}
```

# 87. 扰乱字符串
```
给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。

下图是字符串 s1 = "great" 的一种可能的表示形式。

    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。

例如，如果我们挑选非叶节点 "gr" ，交换它的两个子节点，将会产生扰乱字符串 "rgeat" 。

    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
我们将 "rgeat” 称作 "great" 的一个扰乱字符串。

同样地，如果我们继续交换节点 "eat" 和 "at" 的子节点，将会产生另一个新的扰乱字符串 "rgtae" 。

    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
我们将 "rgtae” 称作 "great" 的一个扰乱字符串。

给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。

示例 1:

输入: s1 = "great", s2 = "rgeat"
输出: true
示例 2:

输入: s1 = "abcde", s2 = "caebd"
输出: false

```

## 代码1（DP，20ms）
```java
class Solution {
    public boolean isScramble(String s1, String s2) {
        // dp[n][i][j]代表s1中起点为i的长度为n的字符串是否为s2中起点为j的长度为n的字符串的扰乱字符串
        // 状态转移公式：dp[n][i][j] = (dp[k][i][j] && dp[n - k][i + k][j + k]) 
        //                           || (dp[k][i][j + n - k] && dp[n - k][i + k][j]), 1 <= k <= n - 1
        // 初始状态：dp[1][i][j] = s1[i] == s2[j]
        
        if (s1.length() != s2.length() || s1.length() == 0) return false;
       
        int n = s1.length();

        boolean[][][] dp = new boolean[n + 1][n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[1][i][j] = s1.charAt(i) == s2.charAt(j);
            }
        }

        for (int k = 2; k <= n; k++) {
            for (int i = n - k; i >= 0; i--) {
                for (int j = n - k; j >= 0; j--) {
                    for (int l = 1; l <= k - 1; l++) {
                        dp[k][i][j] = dp[k][i][j] 
                                        || (dp[l][i][j] && dp[k - l][i + l][j + l]) 
                                        || (dp[l][i][j + k - l] && dp[k - l][i + l][j]);
                    }
                }
            }
        }

        return dp[n][0][0];
    }
}
```

## 代码2（递归 + 优化，2ms）
```java
class Solution {
    public boolean isScramble(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        if (s1.equals(s2)) return true;

        int[] dict = new int[26];

        for (int i = 0; i < s1.length(); i++) {
            dict[s1.charAt(i) - 'a']++;
            dict[s2.charAt(i) - 'a']--;
        }

        for (int i = 0; i < 26; i++) {
            if (dict[i] != 0) return false;
        }

        int n = s1.length();
        for (int i = 1; i < n; i++) {
            if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i, n), s2.substring(i, n))) {
                return true;
            }

            if (isScramble(s1.substring(0, i), s2.substring(n - i, n)) && isScramble(s1.substring(i, n), s2.substring(0, n - i))) {
                return true;
            }
        }

        return false;
    }
}
```

# 91. 解码方法
```
一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例 1:

输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
示例 2:

输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

```

## 代码（DP）
```java
class Solution {
    public int numDecodings(String s) {
        if (s.length() == 0 || s.charAt(0) == '0') return 0;

        int dp0 = 1, dp1 = 1;
        for (int i = 1; i < s.length(); i++) {
            int temp = 0;
            if (s.charAt(i - 1) == '1' || s.charAt(i - 1) == '2' && s.charAt(i) - '0' <= 6) {
                temp += dp0;
            } 

            if (s.charAt(i) != '0') temp += dp1;
            dp0 = dp1;
            dp1 = temp;
        }

        return dp1;
    }
}
```

# 115. 不同的子序列
```
给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。

一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

示例 1:

输入: S = "rabbbit", T = "rabbit"
输出: 3
解释:

如下图所示, 有 3 种可以从 S 中得到 "rabbit" 的方案。
(上箭头符号 ^ 表示选取的字母)

rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^
示例 2:

输入: S = "babgbag", T = "bag"
输出: 5
解释:

如下图所示, 有 5 种可以从 S 中得到 "bag" 的方案。 
(上箭头符号 ^ 表示选取的字母)

babgbag
^^ ^
babgbag
^^    ^
babgbag
^    ^^
babgbag
  ^  ^^
babgbag
    ^^^
```

## 代码1（DP）
```java
class Solution {
    public int numDistinct(String s, String t) {
        // dp[i][j]表示s长度为i的前缀的子序列中t的长度为j的前缀出现的次数

        int[][] dp = new int[s.length() + 1][t.length() + 1];
        for (int i = 0; i <= s.length(); i++) {
            dp[i][0] = 1;
        }

        for (int j = 1; j <= t.length(); j++) {
            for (int i = 1; i <= s.length(); i++) {
                dp[i][j] = dp[i - 1][j];
                if (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] += dp[i - 1][j - 1];
            }
        }

        return dp[s.length()][t.length()];
    }
}
```

## 代码2 （优化为一维数组）
```java

class Solution {
    public int numDistinct(String s, String t) {
        int[] dp = new int[t.length() + 1];
        dp[0] = 1;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = t.length(); j >= 1; j--) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) dp[j] += dp[j - 1];
            }
        }
        return dp[t.length()];
    }
}
```


# 940. 不同的子序列 II

```
给定一个字符串 S，计算 S 的不同非空子序列的个数。

因为结果可能很大，所以返回答案模 10^9 + 7.

 

示例 1：

输入："abc"
输出：7
解释：7 个不同的子序列分别是 "a", "b", "c", "ab", "ac", "bc", 以及 "abc"。
示例 2：

输入："aba"
输出：6
解释：6 个不同的子序列分别是 "a", "b", "ab", "ba", "aa" 以及 "aba"。
示例 3：

输入："aaa"
输出：3
解释：3 个不同的子序列分别是 "a", "aa" 以及 "aaa"。
 

 

提示：

S 只包含小写字母。
1 <= S.length <= 2000
 
```

## 代码

```java
class Solution {
    public int distinctSubseqII(String S) {
        int MOD = (int)1e9 + 7;
        int N = S.length();
        int[] dp = new int[N+1];
        dp[0] = 1;
        int[] last = new int[26];
        Arrays.fill(last, -1);
        for (int i = 0; i < N; ++i) {
            int x = S.charAt(i) - 'a';
            dp[i+1] = dp[i] * 2 % MOD;
            if (last[x] >= 0)
                dp[i+1] -= dp[last[x]];
            dp[i+1] %= MOD;
            last[x] = i;
        }
        dp[N]--;
        if (dp[N] < 0) dp[N] += MOD;
        return dp[N];
    }
}

```

# 139. 单词拆分
```
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
示例 2：

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
示例 3：

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false

```

## 代码
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;

        // 计算wordDict中最长单词的长度
        int maxLength = -1;
        for (String ele: wordDict) {
            maxLength = Math.max(maxLength, ele.length());
        }

        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                // 注意这里对判断条件的优化
                if (i - j <= maxLength && wordDict.contains(s.substring(j, i)) && dp[j]) {
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[s.length()];
    }
}
```

# 140. 单词拆分 II

```
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。

说明：

分隔时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：

输入:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
输出:
[
  "cats and dog",
  "cat sand dog"
]
示例 2：

输入:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
输出:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
解释: 注意你可以重复使用字典中的单词。
示例 3：

输入:
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
输出:
[]
```

## 代码
```java
class Solution {
    public List<String> wordBreak(String s, List<String> wordDict) {
        // 为了防止在一些测试用例上超时，首先复用139题的代码来判断结果是否存在
        if (!wordBreakI(s, wordDict)) return new LinkedList<>();
        
        List<String>[] dp = new List[s.length() + 1];
        dp[0] = new LinkedList<>();
        dp[0].add("");

        int maxLength = -1;
        for (String str: wordDict) maxLength = Math.max(maxLength, str.length());

        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if ((i - j) <= maxLength && wordDict.contains(s.substring(j, i)) && dp[j] != null) {
                    if (dp[i] == null) dp[i] = new LinkedList<>();
                    for (String str: dp[j]) {
                        dp[i].add(str + (str == "" ? "" : " ") + s.substring(j, i));
                    }
                }
            }
        }

        return dp[s.length()] == null ? new LinkedList<String>(): dp[s.length()];
    }

    public boolean wordBreakI(String s, List<String> wordDict) {
        
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;

        int maxLength = -1;
        for (String ele: wordDict) {
            maxLength = Math.max(maxLength, ele.length());
        }

        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (i - j <= maxLength && wordDict.contains(s.substring(j, i)) && dp[j]) {
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[s.length()];
    }
}
```

# 174. 地下城游戏

```
一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

 

编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。

-2 (K)  -3  3
-5  -10 1
10  30  -5 (P)
 

说明:

骑士的健康点数没有上限。

任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

```
## 思路

这是一个多阶段优化问题，有广搜，贪心，动规。这题显然贪心不行，于是范围缩小到广搜和动规。本题求最小健康点数，跟路径长度无关，因此广搜不适合。最后只剩下了动规这个方向。
先定义状态，`f[i][j]`表示进入`(i,j)`这个格子前所需要的最小健康点数。
再考虑状态的初始值，我们发现右下角那个坐标才是初始值，起点`f[0][0]`反而不知道，于是大致可以知道，这题是从右下角向左上角来填表。右下角格子，如果该格子的值为负数，那么进入这个格子前骑士需要的健康点数是`-dungeon[i][j]+1`，即初始值`f[i][j]=-dungeon[i][j]+1`，如果格子的值是非负数，那么初始值`f[i][j]=1`。
接下来寻找状态转移方程。从初始值我们可以推测出状态转移是从右下角反向的，可以得到状态转移方程如下：
`f[i][j]=max(1, -dungeon[i][j]+min(f[i+1][j],f[i][j+1])`
## 代码
```java

// Dungeon Game
// Time Complexity: O(mxn), Space Complexity: O(mxn)
public class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        final int m = dungeon.length;
        final int n = dungeon[0].length;
        if (m == 0 || n == 0) return 0;

        final int[][] f = new int[m][n];
        f[m-1][n-1] = Math.max(1, -dungeon[m-1][n-1]+1);

        for (int i = m - 2; i >= 0; --i) {
            f[i][n-1] = Math.max(1, -dungeon[i][n-1] + f[i+1][n-1]);
        }
        for (int j = n - 2; j >= 0; --j) {
            f[m-1][j] = Math.max(1, -dungeon[m-1][j] + f[m-1][j+1]);
        }

        for (int i = m - 2; i >= 0; --i) {
            for (int j = n - 2; j >= 0; --j) {
                f[i][j] = Math.max(1, -dungeon[i][j] + Math.min(f[i+1][j], f[i][j+1]));
            }
        }
        return f[0][0];
    }
}
```