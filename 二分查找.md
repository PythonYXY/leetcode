
# 69. X的平方根

## 题目描述

```
实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:

输入: 4
输出: 2
示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。

```

## 思路1

用二分法来解决。

需要注意的是本题中排除中位数的逻辑是如果一个数的平方大于输入参数，那它一定不是结果值，可以排除。

另外为了排除死循环，本题中需要选择右中位数。

## 代码1

```java
class Solution {
    public int mySqrt(int x) {
        int left = 0;
        int right = x;
        
        while (left < right) {
            int mid = (left + right + 1) >>> 1;
            
            if (mid > x / mid) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        
        return left;
    }
}
```

## 思路2

使用牛顿迭代法来解决。(From matrix67)


下面这种方法可以很有效地求出根号a的近似值：首先随便猜一个近似值x，然后不断令x等于x和a/x的平均数，迭代个六七次后x的值就已经相当精确了。

 这种算法的原理很简单，我们仅仅是不断用(x,f(x))的切线来逼近方程x^2-a=0的根。根号a实际上就是x^2-a=0的一个正实根，这个函数的导数是2x。也就是说，函数上任一点(x,f(x))处的切线斜率是2x。那么，x-f(x)/(2x)就是一个比x更接近的近似值。代入f(x)=x^2-a得到x-(x^2-a)/(2x)，也就是(x+a/x)/2。
 
 另外为了防止整型溢出的情况出现，循环终止条件判定代码与二分法一样，需要用（r > x / r）而不是（r * r > x)。同时对于迭代方程也要做一下优化，即使用不带符号的右移操作替代除以2。

## 代码2

```java
class Solution {
    public int mySqrt(int x) {
        if (x <= 1) { return x; }
        
        int r = x;
        
        while (r > x / r) {
            r = (r + x / r) >>> 1;
        }
       
        return r;
    }
}
```

# 300. 最长上升子序列

## 题目描述

```
给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?

```

## 思路1（动态规划）

定义状态 dp[i] 为以 nums 中第i个索引的元素为结尾的最长上升子序列的长度（注意必须是以该元素为结尾）

状态转移方程则为：
```
dp[i] = max{1 + dp[j] for j < i if nums[j] < nums[i]}
```

时间复杂度为O(n^2)

## 代码1

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        
        if (nums.length <= 1) return nums.length;
        
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int res = 1;
        
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```
## 思路2（贪心算法+二分查找）

设置一个数组 tail ，tail 中的每一个前缀都是一个最“紧致”的上升子序列。所谓最“紧致”的上升子序列是指在所有相同长度的上升子序列中该子序列的首尾元素差最小（这是贪心的关键）。构造 tail 数组的流程如下：
1、使tail数组初始为空
2、在遍历数组 nums 的过程中，每来一个新数 num，如果这个数**严格大于**有序数组 tail 的最后一个元素，就把 num 放在有序数组 tail 的后面，否则进入第3步
3、在有序数组 tail 中查找第 1 个**严格大于** num 的那个数，用num替换；
4、最后构造出来的 tail 数组的长度即为所求结果。

该算法的时间复杂度为O(n log n) 

## 代码2

借助Collections类库做二分搜索：
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        ArrayList<Integer> tail = new ArrayList<>();
        
        for (int i = 0; i < nums.length; i++) {
            if (tail.size() == 0 || nums[i] > tail.get(tail.size() - 1)) {
                tail.add(nums[i]);
            } else {
                int index = Collections.binarySearch(tail, nums[i]);
                if (index < 0) {
                    tail.set(-index - 1, nums[i]);
                }
            }
        }
        
        return tail.size();
    }
}
```

更高效的版本：
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length <= 1) return nums.length;
        
        int[] tail = new int[nums.length];
        tail[0] = nums[0];
        int end = 0;
        
        for (int i = 1; i < nums.length; i++) {
            // 在遍历数组 nums 的过程中，每来一个新数 num，如果这个数**严格大于**有序数组 tail 的最后一个元素，就把 num 放在有序数组 tail 的后面
            if (nums[i] > tail[end]) {
                tail[++end] = nums[i];
            } else {
                // 在有序数组 tail 中查找第 1 个严格大于 num 的那个数，用num替换
                int left = 0;
                int right = end;
                
                while (left < right) {
                    int mid = (left + right) >>> 1;
                    
                    if (tail[mid] < nums[i]) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                
                tail[left] = nums[i];
            }
        }
        
        return end + 1;
    }
}
```

# 354. 俄罗斯套娃信封问题


## 题目描述

```
给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

说明:
不允许旋转信封。

示例:

输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出: 3 
解释: 最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
```

## 思路

对envelopes数组进行排序后，可以转化成一个最长上升子序列问题。本题的难点就在于选择合适的排序策略。

对envelopes数组进行排序时，首先按照高度升序排序。对于高度相同的元素，按照宽度降序排序，这是因为同一个高度的信封最多只能有一个被选中，所选中的信封是能够容纳前一个被选中的信封中最小宽度的信封。按照LIS算法从左至右的遍历顺序，这样的排序策略更加易于处理。

## 代码

```java
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        
        if (envelopes.length <= 1) return envelopes.length;
        
        Arrays.sort(envelopes, (a, b) -> (a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]));
        
        int[][] tail = new int[envelopes.length][2];
        tail[0] = envelopes[0];
        int end = 0;
        
        for (int i = 1; i < envelopes.length; i++) {
        
            if (envelopes[i][1] > tail[end][1]) {
                tail[++end] = envelopes[i];
            } else {
                int left = 0;
                int right = end;
                
                while (left < right) {
                    int mid = (left + right) >>> 1;
                    
                    if (tail[mid][1] < envelopes[i][1]) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                
                tail[left] = envelopes[i];
            }
        }
    
        return end + 1;
    }
}
```

# 153. 寻找旋转排序数组中的最小值

## 题目描述

```
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

示例 1:

输入: [3,4,5,1,2]
输出: 1
示例 2:

输入: [4,5,6,7,0,1,2]
输出: 0
```

## 思路

使用二分法可以将时间复杂度缩减到O(logn)。

这里排除中位数的逻辑是如果mid上的值大于right上的值，则最小元素一定处于右区间（不包含mid）。
## 代码

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
    
        while (left < right) {
            int mid = (left + right) >>> 1;
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        return nums[left];
    }
}
```

# 154. 寻找旋转排序数组中的最小值 II

## 题目描述

```
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

注意数组中可能存在重复的元素。

示例 1：

输入: [1,3,5]
输出: 1
示例 2：

输入: [2,2,2,0,1]
输出: 0
说明：

这道题是 寻找旋转排序数组中的最小值 的延伸题目。
允许重复会影响算法的时间复杂度吗？会如何影响，为什么？

```

## 思路

在153的基础上增加了重复元素的情况。这里需要额外处理中间元素与末尾元素相同的情况。这种情况下无法判断最小元素是在左区间还是右区间，例如：[2, 0, 1, 2, 2, 2, 2]与[2, 2, 2, 2, 0, 1, 2]，因此只能通过减少right来缩小区间进行进一步的搜索。该算法在最坏情况下的时间复杂度为O(n)。

## 代码

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
    
        while (left < right) {
            int mid = (left + right) >>> 1;
            if (nums[mid] == nums[right]) {
                right--;
            } else if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        return nums[left];
    }
}
```

# 287. 寻找重复数

## 题目描述

```
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

示例 1:

输入: [1,3,4,2,2]
输出: 2
示例 2:

输入: [3,1,3,4,2]
输出: 3
说明：

不能更改原数组（假设数组是只读的）。
只能使用额外的 O(1) 的空间。
时间复杂度小于 O(n2) 。
数组中只有一个重复的数字，但它可能不止重复出现一次。
```

## 思路1（二分法）


这道题的关键是对要定位的“数”做二分，而不是对数组的索引做二分。要定位的“数”根据题意在 1 和 n 之间，每一次二分都可以将搜索区间缩小一半。

## 代码1
```java
public class Solution {

    public int findDuplicate(int[] nums) {
        int len = nums.length;
        int left = 1;
        int right = len - 1;
        while (left < right) {
            // int mid = left + (right - left) / 2;
            int mid = (left + right) >>> 1;
            int counter = 0;
            for (int num : nums) {
                if (num <= mid) {
                    counter += 1;
                }
            }
            if (counter > mid) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}

```

## 思路2（快慢指针）

将数组内的元素值看作是该节点指向的下个节点在数组中的索引值，这样就可以将数组转化为链表进行处理。由于元素值是从1开始，而索引值是从0开始，因此链表的长度为最大元素值加1，也就是说链表中一定存在两个节点有着相同的值，它们指向同一个节点，也即链表中有环的存在。因此本题可以转化为寻找链表中环入口的问题。具体可参考题目环形链表 II的解法：



设置快慢指针从A1出发。假设slow和fast在A3相遇，根据以上公式（fast在与slow相遇前走过了k圈）。head从A1出发，slow从A3出发，经过a步以后，两点将在A2（环的入口）相遇。

## 代码2

```java
public class Solution {

    public int findDuplicate(int[] nums) {
        int slow = 0, fast = 0;
        
        while (slow != fast || fast == 0) {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        
        int res = 0;
        while (res != slow) {
            res = nums[res];
            slow = nums[slow];
        }
        
        return res;
    }
}

```