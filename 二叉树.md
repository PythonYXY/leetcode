# 144. 二叉树的前序遍历
```
给定一个二叉树，返回它的 前序 遍历。

 示例:

输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？

```

## 思路
使用Morris Traversal的方法前序遍历二叉树。

Morris方法可以做到：
1、时间复杂度为O(n)，空间复杂度为O(1)
2、不破坏二叉树的形状

步骤：

1. 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。

2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。

   a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。输出当前节点，然后将当前节点更新为当前节点的左孩子。

   b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。。当前节点更新为当前节点的右孩子。

3. 重复以上1、2直到当前节点为空。

时间复杂度为O(n)的原因：对于二叉树任意两个节点之间的边，在遍历过程中最多经过3次：一次用于找到前驱节点，一次遍历子节点，还有一次将前驱节点的右子节点还原。

对于中序遍历，只需要将上述算法第2a步中的「输出当前节点」移动到2b步即可。
## 代码
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        
        TreeNode cur = root, prev;
        List<Integer> res = new ArrayList<>();

        while (cur != null) {
            if (cur.left == null) {
                res.add(cur.val);
                cur = cur.right;    
            } else {
                prev = cur.left;
                while (prev.right != null && prev.right != cur) {
                    prev = prev.right;
                }

                if (prev.right == null) {
                    prev.right = cur;
                    res.add(cur.val);
                    cur = cur.left;
                } else {
                    prev.right = null;
                    // res.add(cur.val);
                    cur = cur.right;
                }
            }
        }
        return res;
    }
}
```

# 145. 二叉树的后序遍历
```
给定一个二叉树，返回它的 后序 遍历。

示例:

输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？

```

## 思路1
后序遍历的顺序是先遍历左子节点，然后遍历右子节点，最后遍历父节点。

用迭代的方法，可以先遍历父节点，然后遍历右子节点，最后遍历左子节点。然后将遍历结果反转即可。


## 代码1
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        if (root == null) return new LinkedList<>();
        
        TreeNode cur, prev;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        LinkedList<Integer> res = new LinkedList<>();
        
        while (!stack.empty()) {
            cur = stack.pop();
            res.addFirst(cur.val);
            
            if (cur.left != null) {
                stack.push(cur.left);
            }
            
            if (cur.right != null) {
                stack.push(cur.right);
            }
        }
        
        return res;
    }
}
```

## 思路2
依旧是Morris遍历法。

当前节点设置为临时节点dump。

1. 如果当前节点的左孩子为空，则将其右孩子作为当前节点。

2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。

   a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。

   b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空。倒序输出从当前节点的左孩子到该前驱节点这条路径上的所有节点。当前节点更新为当前节点的右孩子。

3. 重复以上1、2直到当前节点为空。
## 代码2
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        TreeNode dummy = new TreeNode(-1);
        dummy.left = root;
        
        List<Integer> res = new ArrayList<>();

        TreeNode cur = dummy, prev;

        while (cur != null) {
            if (cur.left == null) {
                cur = cur.right;
            } else {
                prev = cur.left;
                while (prev.right != null && prev.right != cur) {
                    prev = prev.right;
                }
                
                if (prev.right == null) {
                    prev.right = cur;
                    cur = cur.left;
                } else {
                    prev.right = null;
                    res.addAll(helper(cur.left, prev));
                    cur = cur.right;
                }
            }
        }
        
        return res;
    }
    
    public LinkedList<Integer> helper(TreeNode cur, TreeNode prev) {
        LinkedList<Integer> ret = new LinkedList<>();
        
        while (cur != prev) {
            ret.addFirst(cur.val);
            cur = cur.right;
        }
        
        ret.addFirst(prev.val);
        return ret;
    }
}
```

## 思路3

将Morris前序遍历法结合思路1

## 代码3
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        if (root == null) return new LinkedList<>();
        TreeNode cur = root, prev;
        LinkedList<Integer> res = new LinkedList<>();
        while (cur != null) {
            if (cur.right == null) {
                res.addFirst(cur.val);
                cur = cur.left;
            } else {
                prev = cur.right;
                
                while (prev.left != null && prev.left != cur) {
                    prev = prev.left;
                }
                
                if (prev.left == null) {
                    prev.left = cur;
                    res.addFirst(cur.val);
                    cur = cur.right;
                } else {
                    prev.left = null;
                    cur = cur.left;
                }
            }
        }
        
        return res;
    }
}
```

# 173. 二叉搜索树迭代器
```
实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。

调用 next() 将返回二叉搜索树中的下一个最小的数。

 

示例：



BSTIterator iterator = new BSTIterator(root);
iterator.next();    // 返回 3
iterator.next();    // 返回 7
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 9
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 15
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 20
iterator.hasNext(); // 返回 false
 

提示：

next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。
你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。
```

## 思路

## 代码
```java
// Binary Search Tree Iterator
public class BSTIterator {
    public BSTIterator(TreeNode root) {
        stack = new Stack<>();
        while (root != null) {
            stack.push(root);
            root = root.left;
        }
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    /** @return the next smallest number */
    public int next() {
        final TreeNode node = stack.pop();
        if (node.right != null) {
            TreeNode p = node.right;
            while (p != null) {
                stack.push(p);
                p = p.left;
            }

        }
        return node.val;
    }
    private Stack<TreeNode> stack;
}
```

# 99. 恢复二叉搜索树

```
二叉搜索树中的两个节点被错误地交换。

请在不改变其结构的情况下，恢复这棵树。

示例 1:

输入: [1,3,null,null,2]

   1
  /
 3
  \
   2

输出: [3,1,null,null,2]

   3
  /
 1
  \
   2
示例 2:

输入: [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2

输出: [2,1,4,null,null,3]

  2
 / \
1   4
   /
  3
进阶:

使用 O(n) 空间复杂度的解法很容易实现。
你能想出一个只使用常数空间的解决方案吗？

```

## 思路
首先考虑如何在遍历一维数组的过程中交换两个逆序元素。设置cur指向当前元素，prev指向上一个元素。如果在遍历过程中第一次出现cur元素值小于prev元素值，则prev一定是第一个逆序元素。但是此时cur可能是也可能不是第二个逆序元素，这取决于后续遍历过程中会不会再次出现cur元素值小于prev元素值的情况。

## 代码1（递归遍历，空间复杂度O(logn)）
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    TreeNode node1, node2, prev;
    
    public void recoverTree(TreeNode root) {
        inorderTraversal(root);
        int temp = node1.val;
        node1.val = node2.val;
        node2.val = temp;
    }
    
    public void inorderTraversal(TreeNode root) {
        if (root == null) return;
        inorderTraversal(root.left);
        
        if (prev != null && root.val < prev.val) {
            if (node1 == null) {
                node1 = prev;
                node2 = root;
            } else {
                node2 = root;
            }
        }
        
        prev = root;
        inorderTraversal(root.right);
    }
}
```

## 代码2（Morris遍历法，空间复杂度O(1)）
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    TreeNode curPrev, node1, node2;
    
    public void recoverTree(TreeNode root) {
        if (root == null) return;
        
        TreeNode cur = root, prev;
        while (cur != null) {
            if (cur.left == null) {
                
                if (curPrev != null && cur.val < curPrev.val) {
                    if (node1 == null) {
                        node1 = curPrev;
                        node2 = cur;
                    } else {
                        node2 = cur;
                    }
                }
                
                curPrev = cur;
                cur = cur.right;
            } else {
                prev = cur.left;
                
                while (prev.right != null && prev.right != cur) {
                    prev = prev.right;
                }
                
                if (prev.right == null) {
                    prev.right = cur;
                    cur = cur.left;
                } else {
                    prev.right = null;
                    
                    if (curPrev != null && cur.val < curPrev.val) {
                        if (node1 == null) {
                            node1 = curPrev;
                            node2 = cur;
                        } else {
                            node2 = cur;
                        }
                    }
                
                    curPrev = cur;
                    cur = cur.right;
                }
            }
        }
        
        int temp = node1.val;
        node1.val = node2.val;
        node2.val = temp;
    }
    
}
```

# 110. 平衡二叉树
```

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。
```

## 代码
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        return computeTreeHeight(root) != -1;
    }
    
    public int computeTreeHeight(TreeNode node) {
        if (node == null) return 0;
        
        int left = computeTreeHeight(node.left);
        int right = computeTreeHeight(node.right);
        
        if (left == -1 || right == -1 || Math.abs(right - left) > 1) return -1;
        return Math.max(left, right) + 1;
    }
}
```

# 114. 二叉树展开为链表
```
给定一个二叉树，原地将它展开为链表。

例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
## 代码
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        if (root == null) return;
        helper(root, null);
    }
    
    public TreeNode helper(TreeNode node, TreeNode tail) {
        if (node == null) return tail;
        node.right = helper(node.left, helper(node.right, tail));
        node.left = null;
        return node;
    }
}
```

# 117. 填充每个节点的下一个右侧节点指针 II
```
给定一个二叉树

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

 

进阶：

你只能使用常量级额外空间。
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
 

示例：



输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。
 

提示：

树中的节点数小于 6000
-100 <= node.val <= 100
 

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 代码
```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/
class Solution {
    public Node connect(Node root) {
        Node cur = root;
        
        while (cur != null) {
            Node dummy = new Node(-1);
            Node tail = dummy;
            
            while (cur != null) {
                if (cur.left != null) {
                    tail.next = cur.left;
                    tail = tail.next;
                }
                
                if (cur.right != null) {
                    tail.next = cur.right;
                    tail = tail.next;
                }
                
                cur = cur.next;
            }
            
            cur = dummy.next;
        }
        
        return root;
    }
}
```

# 96. 不同的二叉搜索树
```
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/unique-binary-search-trees
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 思路
动态规划的方法自不必说，这里主要说下公式法。

卡塔兰公式为 `Cn = C(n, 2n) / (n + 1)`。由于直接求阶乘会导致溢出，所以考虑将其转换为迭代公式。

由于`Cn+1 = C(n + 1, 2n + 2) / (n + 2)`， 那么`Cn+1 / Cn = (4n + 2) / (n + 2)`。

# 95. 不同的二叉搜索树 II
```
给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。

示例:

输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 代码
```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<TreeNode> generateTrees(int n) {
        if (n <= 0) return new LinkedList<>();
        return generateTrees(1, n);
    }
    public List<TreeNode> generateTrees(int start, int end) {
        if (end < start) {
            List<TreeNode> nullList = new LinkedList<>();
            nullList.add(null);
            return nullList;
        }
        List<TreeNode> ret = new LinkedList<>();
        for (int i = start; i <= end; i++) {
            List<TreeNode> temp1 = generateTrees(start, i - 1);
            List<TreeNode> temp2 = generateTrees(i + 1, end);
            for (TreeNode l: temp1) {
                for (TreeNode r: temp2) {
                    TreeNode root = new TreeNode(i);
                    root.left = l;
                    root.right = r;
                    ret.add(root);
                }
            }
        }
        return ret;
    }
}


```

# 236. 二叉树的最近公共祖先
```
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]



 

示例 1:

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
示例 2:

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
 

说明:

所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉树中。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 代码
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return null;

        if (root == p || root == q) return root;

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if (left != null && right != null) {
            return root;
        } else if (left != null) {
            return left;
        } else if (right != null) {
            return right;
        }

        return null;
    }
}
```

# 230. 二叉搜索树中第K小的元素
```
给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

说明：
你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

示例 1:

输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 1
示例 2:

输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 3
进阶：
如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 思路
如果能够修改节点的数据结构TreeNode，可以增加一个字段leftCnt，表示左子树的节点个数。设当前节点为root，
- 若 k == root.leftCnt+1, 则返回root
- 若 k > node.leftCnt, 则 k -= root.leftCnt+1, root=root.right
- 否则，node = node.left

算法复杂度为O(height of BST)

## 代码
```java
// Kth Smallest Element in a BST
// Time Complexity: O(k), Space Complexity: O(h)
public class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Stack s = new Stack<>();
        TreeNode p = root;

        while (!s.empty() || p != null) {
            if (p != null) {
                s.push(p);
                p = p.left;
            } else {
                p = s.pop();
                --k;
                if (k == 0) {
                    return p.val;
                }
                p = p.right;
            }
        }
        return -1;
    }
}
```

# 113. 路径总和 II
```
给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

说明: 叶子节点是指没有子节点的节点。

示例:
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
返回:

[
   [5,4,11,2],
   [5,8,4,5]
]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/path-sum-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 代码
```java
// Path Sum II
// 时间复杂度O(n)，空间复杂度O(logn)
public class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> result = new ArrayList<>();
        ArrayList<Integer>  cur = new ArrayList<>(); // 中间结果
        pathSum(root, sum, cur, result);
        return result;
    }
    private static void pathSum(TreeNode root, int gap, ArrayList<Integer> cur, List<List<Integer>> result) {
        if (root == null) return;

        cur.add(root.val);

        if (root.left == null && root.right == null) { // leaf
            if (gap == root.val)
                result.add(new ArrayList<>(cur));
        }
        pathSum(root.left, gap - root.val, cur, result);
        pathSum(root.right, gap - root.val, cur, result);

        cur.remove(cur.size() - 1);
    }
}
```

#  307. 区域和检索 - 数组可修改
```
给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。

update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。

示例:

Given nums = [1, 3, 5]

sumRange(0, 2) -> 9
update(1, 2)
sumRange(0, 2) -> 8
说明:

数组仅可以在 update 函数下进行修改。
你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/range-sum-query-mutable
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```


## 代码（线段树）
```java

class NumArray {
    private SegmentTree root;
    class SegmentTree {
        public int begin;
        public int end;
        public int sum;
        public SegmentTree left;
        public SegmentTree right;
        public SegmentTree(int begin, int end, int sum) {
            this.begin = begin;
            this.end = end;
            this.sum = sum;
        }
        public SegmentTree(int begin, int end) {
            this.begin = begin;
            this.end = end;
            this.sum = 0;
        }
    }
    public SegmentTree buildTree(int[] nums, int l, int r) {
        if (l > r) return null;
        if (l == r) return new SegmentTree(l, r, nums[l]);
        int mid = (l + r) >>> 1;
        SegmentTree root = new SegmentTree(l, r);
        root.left = buildTree(nums, l, mid);
        root.right = buildTree(nums, mid + 1, r);
        root.sum = root.left.sum + root.right.sum;
        return root;
    }
    public int sumRangeHelper(SegmentTree root, int i, int j) {
        // System.out.println(i + ", " + j + "; " + root.begin + ", " + root.end);
        if (i == root.begin && j == root.end) {
            return root.sum;
        }
        int mid = (root.begin + root.end) >>> 1;
        if (j <= mid) {
            return sumRangeHelper(root.left, i, j);
        } else if (i > mid) {
            return sumRangeHelper(root.right, i, j);
        } else {
            return sumRangeHelper(root.left, i, mid) + sumRangeHelper(root.right, mid + 1, j);
        }
    }
    public void updateHelper(SegmentTree root, int i, int val) {
        if (root.begin == root.end && root.begin == i) {
            root.sum = val;
            return; 
        }
        int mid = (root.begin + root.end) >>> 1;
        if (i <= mid) {
            updateHelper(root.left, i, val);
        } else {
            updateHelper(root.right, i, val);
        }
        root.sum = root.left.sum + root.right.sum;
    }
    public NumArray(int[] nums) {
        root = buildTree(nums, 0, nums.length - 1);
    }
    
    public void update(int i, int val) {
        updateHelper(root, i, val);
    }
    
    public int sumRange(int i, int j) {
        return sumRangeHelper(root, i, j);
    }
}
/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(i,val);
 * int param_2 = obj.sumRange(i,j);
 */


```

# 129. 求根到叶子节点数字之和
```
给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。

例如，从根到叶子节点路径 1->2->3 代表数字 123。

计算从根到叶子节点生成的所有数字之和。

说明: 叶子节点是指没有子节点的节点。

示例 1:

输入: [1,2,3]
    1
   / \
  2   3
输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12.
从根到叶子节点路径 1->3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.
示例 2:

输入: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
输出: 1026
解释:
从根到叶子节点路径 4->9->5 代表数字 495.
从根到叶子节点路径 4->9->1 代表数字 491.
从根到叶子节点路径 4->0 代表数字 40.
因此，数字总和 = 495 + 491 + 40 = 1026.

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```

## 代码
```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int sumNumbers(TreeNode root) {
        return sumNumbersHelper(root, 0);
    }
    public int sumNumbersHelper(TreeNode root, int sum) {
        if (root == null) return 0;
        if (root.left == null && root.right == null) return sum * 10 + root.val;
        return sumNumbersHelper(root.left, sum * 10 + root.val) + sumNumbersHelper(root.right, sum * 10 + root.val);
    }
}

```