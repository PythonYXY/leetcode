# 187. 重复的DNA序列
```
所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。

编写一个函数来查找 DNA 分子中所有出现超过一次的 10 个字母长的序列（子串）。

 

示例：

输入：s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
输出：["AAAAACCCCC", "CCCCCAAAAA"]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/repeated-dna-sequences
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 代码
```java
class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
        // A -> 65 -> 0100 0001 -> 001
        // C -> 67 -> 0100 0011 -> 011
        // G -> 71 -> 0100 0111 -> 111
        // T -> 84 -> 0101 0100 -> 100
        if (s.length() < 10) return new LinkedList<>();
        Set<String> ret = new HashSet<>();
        Set<Integer> set = new HashSet<>();
        char[] arr = s.toCharArray();
        int key = 0;

        for (int i = 0; i < 10; i++) {
            key <<= 3;
            key |= (arr[i] & 7);
        }

        set.add(key);

        for (int i = 10; i < s.length(); i++) {
            key <<= 3;
            key |= (arr[i] & 7);
            key &= 0x3fffffff;

            if (set.contains(key)) {
                ret.add(s.substring(i - 9, i + 1));
            } else {
                set.add(key);
            }
        }

        return new ArrayList<>(ret);
    }
}
```

# 52. N皇后 II
```
n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。



上图为 8 皇后问题的一种解法。

给定一个整数 n，返回 n 皇后不同的解决方案的数量。

示例:

输入: 4
输出: 2
解释: 4 皇后问题存在如下两个不同的解法。
[
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/n-queens-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 代码
```java
class Solution {
    public int sum = 0;

    public int totalNQueens(int n) {
        dfs(0, 0, 0, (1 << n) - 1);
        return sum;
    }

    // row: 之前行上的皇后向下投射的位置为1
    // rd:  之前行上的皇后向右下斜对角投射的位置为1
    // ld:  之前行上的皇后向左下斜对角投射的位置为1
    public void dfs(int row, int rd, int ld, int upperLim) {
        // 所有行都有一个有效的皇后，解法增1
        if (row == upperLim) {
            sum++;
            return;
        }

        // 计算当前行还可以放置皇后的位置
        int pos = upperLim & ~(row | rd | ld);

        while (pos != 0) {
            // 计算pos最靠右的1的位置
            int p = pos & (~pos + 1);
            pos -= p;
            dfs(row + p, (rd + p) >> 1, (ld + p) << 1, upperLim);
        }
    }
}
```

# 51. N皇后
```
n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。



上图为 8 皇后问题的一种解法。

给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。

每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

示例:

输入: 4
输出: [
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]
解释: 4 皇后问题存在两个不同的解法。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/n-queens
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 代码
```java
class Solution {
    private List<List<String>> res = new LinkedList<>();

    public List<List<String>> solveNQueens(int n) {
        ArrayList<String> arr = new ArrayList<>();
        for (int i = 0; i < n; i++) arr.add("");
        dfs(0, 0, 0, (1 << n) - 1, arr);
        return res;
    }

    // row: 之前行上的皇后向下投射的位置为1
    // rd:  之前行上的皇后向右下斜对角投射的位置为1
    // ld:  之前行上的皇后向左下斜对角投射的位置为1
    public void dfs(int row, int rd, int ld, int upperLim, ArrayList<String> arr) {
        // 所有行都有一个有效的皇后，解法增1
        if (row == upperLim) {
            // 一定要在res中添加新创建的arrayList
            res.add(new ArrayList(arr));
            return;
        }

        // 计算当前行还可以放置皇后的位置
        int pos = upperLim & ~(row | rd | ld);

        while (pos != 0) {
            // 计算pos最靠右的1的位置
            int p = pos & (~pos + 1);
            pos -= p;
            arr.set(countOnes(row), rowStr(p, arr.size()));
            dfs(row + p, (rd + p) >> 1, (ld + p) << 1, upperLim, arr);
        }
    }

    // private int countOnes(int n) {
    //     int sum = 0;
    //     while (n != 0) {
    //         sum += n & 1;
    //         n >>= 1;
    //     }

    //     return sum;
    // }

    // 为了求整型n中1的个数，可以采用分而治之的方法
    // 第一行首先计算n中相邻2位的和，由于相邻两位的和最大也只为2（即只占用2个比特位），因此相邻两位的计算结果可以存储在本地（即当前两个比特位中），不会影响其他比特位。
    // 0x55555555的二进制为：01010101010101010101010101010101，也即01互相间隔。n和0x55555555的与结果加上n右移一位后和0x55555555的与结果正是n中相邻两位的和
    //接着继续计算n中相邻4位的和，8位的和。。。直到相邻32位的和
    private int countOnes(int n) {
        n = (n & 0x55555555) + ((n >> 1) & 0x55555555);
        n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
        n = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);
        n = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);
        n = (n & 0x0000ffff) + ((n >> 16) & 0x0000ffff);
        return n;
    }

    private String rowStr(int p, int n) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            sb.insert(0, (p & 1) == 1 ? 'Q' : '.');
            p >>= 1;
        }

        return sb.toString();
    }
}
```

# 89. 格雷编码
```
格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。

示例 1:

输入: 2
输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2

对于给定的 n，其格雷编码序列并不唯一。
例如，[0,2,3,1] 也是一个有效的格雷编码序列。

00 - 0
10 - 2
11 - 3
01 - 1
示例 2:

输入: 0
输出: [0]
解释: 我们定义格雷编码序列必须以 0 开头。
     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。
     因此，当 n = 0 时，其格雷编码序列为 [0]。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/gray-code
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 思路1
找规律：
位数为2时的格雷码为：
0 -> 00
1 -> 01
3 -> 11
2 -> 10

当位数为3时，在所有位数为2的格雷码前添加一个0并不会破坏两个连续的数值仅有一个位数的差异这条规则，而且其值保持不变，如下：
0 -> 000
1 -> 001
3 -> 011
2 -> 010

然后考虑在原有位数为2的格雷码前添加1，可以看到按照原有顺序添加1后第一个值100与添加0后的最后一个值010之间并不连续。但是注意到格雷码反转后其两个连续数值依然仅有一个位数的差异，同时在10前添加1后的110与010是连续的。所以可以将原有位数为2的格雷码反转后在前面添加一个1，然后拼接到之前添加0后的格雷码后面。这样位数为3的格雷码就形成了，同时前1/2个格雷码与位数为2的格雷码相同。
## 代码1
```java

class Solution {
    public List<Integer> grayCode(int n) {
        ArrayList<Integer> ret = new ArrayList<>();
        ret.add(0);
        for (int i = 0; i < n; i++) {
            int p = 1 << i;
            for (int j = ret.size() - 1; j >= 0; j--) {
                ret.add(ret.get(j) + p);
            }
        }
        return ret;
    }
}
```

## 代码2（公式法）
```java
class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> ret = new ArrayList<>();
        for (int i = 0; i < 1 << n; i++) ret.add(i ^ i >> 1);
        return ret;
    }
}
```

# 136. 只出现一次的数字
```
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/single-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 思路
三条规则：
交换律：`a ^ b ^ c <=> a ^ c ^ b`
任何数于0异或为任何数 `0 ^ n => n`
相同的数异或为0: `n ^ n => 0`

例子：
`var a = [2,3,2,4,4]`

`2 ^ 3 ^ 2 ^ 4 ^ 4 => 2 ^ 2 ^ 4 ^ 4 ^ 3 => 0 ^ 0 ^3 => 3`
## 代码
```java
class Solution {
    public int singleNumber(int[] nums) {
        int ret = 0;
        for (int i = 0; i < nums.length; i++) ret ^= nums[i];
        return ret;
    }
}
```

# 137. 只出现一次的数字 II
```
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,3,2]
输出: 3
示例 2:

输入: [0,1,0,1,0,1,99]
输出: 99

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/single-number-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 代码
```java
class Solution {
    public int singleNumber(int[] nums) {
        int one = 0, two = 0, three = 0;
        for (int i = 0; i < nums.length; i++) {
            // two用来记录出现两次1的位
            two |= one & nums[i];
            // one用来记录出现一次1的位
            one ^= nums[i];
            // three记录出现三次1的位
            three = one & two;
            
            // 消除掉出现三次的位
            one ^= three;
            two ^= three;
        }

        return one;
    }
}
```

## 260. 只出现一次的数字 III
```
给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

示例 :

输入: [1,2,1,3,2,5]
输出: [3,5]
注意：

结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。
你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/single-number-iii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 代码
```java
class Solution {
    public int[] singleNumber(int[] nums) {
        // xor为两个结果元素异或的结果
        int xor = 0;
        for (int i = 0; i < nums.length; i++) {
            xor ^= nums[i];
        }
        
        // 由于两个结果元素不相同，所以至少存在一位在异或后为1
        int k = 0;
        for (; k < 32; k++) {
            if (((xor >> k) & 1) == 1) break;
        }
        
        // 利用k排除掉其中一个元素，找出另一个元素
        int res1 = 0;
        for (int i = 0; i < nums.length; i++) {
            if (((nums[i] >> k) & 1) == 1) res1 ^= nums[i];
        }

        return new int[] {res1, res1 ^ xor};
    }
}
```

# 201. 数字范围按位与
```
给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

示例 1: 

输入: [5,7]
输出: 4
示例 2:

输入: [0,1]
输出: 0

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/bitwise-and-of-numbers-range
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 代码

```java
class Solution {
    public int rangeBitwiseAnd(int m, int n) {
        int offset = 0;
        while (m != n) {
            m >>= 1;
            n >>= 1;
            offset++;
        }

        m <<= offset;
        return m;
    }
}
```

# 1275. 找出井字棋的获胜者
```
A 和 B 在一个 3 x 3 的网格上玩井字棋。

井字棋游戏的规则如下：

玩家轮流将棋子放在空方格 (" ") 上。
第一个玩家 A 总是用 "X" 作为棋子，而第二个玩家 B 总是用 "O" 作为棋子。
"X" 和 "O" 只能放在空方格中，而不能放在已经被占用的方格上。
只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。
如果所有方块都放满棋子（不为空），游戏也会结束。
游戏结束后，棋子无法再进行任何移动。
给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。

如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 "Draw"；如果仍会有行动（游戏未结束），则返回 "Pending"。

你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。

 

示例 1：

输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
输出："A"
解释："A" 获胜，他总是先走。
"X  "    "X  "    "X  "    "X  "    "X  "
"   " -> "   " -> " X " -> " X " -> " X "
"   "    "O  "    "O  "    "OO "    "OOX"
示例 2：

输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
输出："B"
解释："B" 获胜。
"X  "    "X  "    "XX "    "XXO"    "XXO"    "XXO"
"   " -> " O " -> " O " -> " O " -> "XO " -> "XO " 
"   "    "   "    "   "    "   "    "   "    "O  "
示例 3：

输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
输出："Draw"
输出：由于没有办法再行动，游戏以平局结束。
"XXO"
"OOX"
"XOX"
示例 4：

输入：moves = [[0,0],[1,1]]
输出："Pending"
解释：游戏还没有结束。
"X  "
" O "
"   "
 

提示：

1 <= moves.length <= 9
moves[i].length == 2
0 <= moves[i][j] <= 2
moves 里没有重复的元素。
moves 遵循井字棋的规则。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 代码
```java
class Solution {
    public String tictactoe(int[][] moves) {
        int[] win = new int[]{448, 56, 7, 292, 146, 73, 273, 84};

        int a = 0, b = 0;
        for (int i = 0; i < moves.length; i++) {
            if (i % 2 == 0) {
                a |= 1 << (moves[i][0] * 3 + moves[i][1]);
            } else {
                b |= 1 << (moves[i][0] * 3 + moves[i][1]);
            }
        }

        for (int i = 0; i < 8; i++) {
            if ((win[i] & a) == win[i]) return "A";
            if ((win[i] & b) == win[i]) return "B";
        }

        if (moves.length < 9) return "Pending";
        else return "Draw";
    }
}
```